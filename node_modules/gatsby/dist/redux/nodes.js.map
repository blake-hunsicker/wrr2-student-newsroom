{"version":3,"sources":["../../src/redux/nodes.ts"],"names":["getNodes","nodes","store","getState","Array","from","values","getNode","id","get","getNodesByType","type","nodesByType","getTypes","keys","hasNodeChanged","digest","node","internal","contentDigest","getNodeAndSavePathDependency","path","console","error","undefined","nodeId","saveResolvedNodes","nodeTypeNames","resolver","typeName","resolvedNodes","Map","resolved","set","dispatch","payload","key","getResolvedNode","resolvedNodesCache","__gatsby_resolved","addResolvedNodes","resolvedNodesFromCache","forEach","push","postIndexingMetaSetup","filterCache","op","postIndexingMetaSetupNeNin","includes","postIndexingMetaSetupLtLteGtGte","arr","meta","nodesUnordered","byValue","v","entriesNullable","entries","filter","sort","a","b","orderedNodes","orderedValues","offsets","bucket","length","size","valuesAsc","nodesByValueAsc","valueRangesAsc","valuesDesc","nodesByValueDesc","valueRangesDesc","ensureIndexByQuery","filterCacheKey","filterPath","filtersCache","state","addNodeToFilterCache","ensureEmptyFilterCache","chain","valueOffset","i","nextProp","isArray","markNodeForValue","value","Set","add","ensureIndexByElemMatch","addNodeToBucketWithElemMatch","valueAtCurrentStep","nestedQuery","elem","binarySearchAsc","needle","min","max","pivot","Math","floor","binarySearchDesc","getNodesFromCacheByValue","filterValue","Error","filterValueArr","slice","cache","delete","RegExp","regex","result","test","String","ranges","range","point","pivotMin","pivotMax","pivotValue","exclPivot","inclPivot","until"],"mappings":"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","sourcesContent":["import { store } from \"./\"\nimport { IGatsbyNode } from \"./types\"\nimport { createPageDependency } from \"./actions/add-page-dependency\"\nimport { IDbQueryElemMatch } from \"../db/common/query\"\n\n// Only list supported ops here. \"CacheableFilterOp\"\ntype FilterOp =\n  | \"$eq\"\n  | \"$ne\"\n  | \"$lt\"\n  | \"$lte\"\n  | \"$gt\"\n  | \"$gte\"\n  | \"$in\"\n  | \"$nin\"\n  | \"$regex\" // Note: this includes $glob\n// Note: `undefined` is an encoding for a property that does not exist\ntype FilterValueNullable =\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n  | RegExp // Only valid for $regex\n  | Array<string | number | boolean | null | undefined>\n// This is filter value in most cases\ntype FilterValue =\n  | string\n  | number\n  | boolean\n  | RegExp // Only valid for $regex\n  | Array<string | number | boolean>\nexport type FilterCacheKey = string\nexport interface IFilterCache {\n  op: FilterOp\n  // In this set, `undefined` values represent nodes that did not have the path\n  byValue: Map<FilterValueNullable, Set<IGatsbyNode>>\n  meta: {\n    // Unordered unfiltered flat set of _all_ nodes of requested type(s)\n    nodesUnordered?: Array<IGatsbyNode>\n    // Ordered set of all values (by `<`) found by this filter. No null / undefs\n    valuesAsc?: Array<FilterValue>\n    // Flat set of nodes, ordered by valueAsc, but not ordered per value group\n    nodesByValueAsc?: Array<IGatsbyNode>\n    // Ranges of nodes per value, maps to the nodesByValueAsc array\n    valueRangesAsc?: Map<FilterValue, [number, number]>\n    // Ordered set of all values (by `>`) found by this filter. No null / undefs\n    valuesDesc?: Array<FilterValue>\n    // Flat set of nodes, ordered by valueDesc, but not ordered per value group\n    nodesByValueDesc?: Array<IGatsbyNode>\n    // Ranges of nodes per value, maps to the nodesByValueDesc array\n    valueRangesDesc?: Map<FilterValue, [number, number]>\n  }\n}\nexport type FiltersCache = Map<FilterCacheKey, IFilterCache>\n\n/**\n * Get all nodes from redux store.\n */\nexport const getNodes = (): IGatsbyNode[] => {\n  const nodes = store.getState().nodes\n  if (nodes) {\n    return Array.from(nodes.values())\n  } else {\n    return []\n  }\n}\n\n/**\n * Get node by id from store.\n */\nexport const getNode = (id: string): IGatsbyNode | undefined =>\n  store.getState().nodes.get(id)\n\n/**\n * Get all nodes of type from redux store.\n */\nexport const getNodesByType = (type: string): IGatsbyNode[] => {\n  const nodes = store.getState().nodesByType.get(type)\n  if (nodes) {\n    return Array.from(nodes.values())\n  } else {\n    return []\n  }\n}\n\n/**\n * Get all type names from redux store.\n */\nexport const getTypes = (): string[] =>\n  Array.from(store.getState().nodesByType.keys())\n\n/**\n * Determine if node has changed.\n */\nexport const hasNodeChanged = (id: string, digest: string): boolean => {\n  const node = store.getState().nodes.get(id)\n  if (!node) {\n    return true\n  } else {\n    return node.internal.contentDigest !== digest\n  }\n}\n\n/**\n * Get node and save path dependency.\n */\nexport const getNodeAndSavePathDependency = (\n  id: string,\n  path: string\n): IGatsbyNode | undefined => {\n  const node = getNode(id)\n\n  if (!node) {\n    console.error(\n      `getNodeAndSavePathDependency failed for node id: ${id} as it was not found in cache`\n    )\n    return undefined\n  }\n\n  createPageDependency({ path, nodeId: id })\n  return node\n}\n\ntype Resolver = (node: IGatsbyNode) => Promise<any> // TODO\n\nexport const saveResolvedNodes = async (\n  nodeTypeNames: string[],\n  resolver: Resolver\n): Promise<void> => {\n  for (const typeName of nodeTypeNames) {\n    const nodes = store.getState().nodesByType.get(typeName)\n    if (!nodes) return\n\n    const resolvedNodes = new Map()\n    for (const node of nodes.values()) {\n      const resolved = await resolver(node)\n      resolvedNodes.set(node.id, resolved)\n    }\n    store.dispatch({\n      type: `SET_RESOLVED_NODES`,\n      payload: {\n        key: typeName,\n        nodes: resolvedNodes,\n      },\n    })\n  }\n}\n\n/**\n * Get node and save path dependency.\n */\nexport const getResolvedNode = (\n  typeName: string,\n  id: string\n): IGatsbyNode | null => {\n  const { nodesByType, resolvedNodesCache } = store.getState()\n  const nodes = nodesByType.get(typeName)\n\n  if (!nodes) {\n    return null\n  }\n\n  const node = nodes.get(id)\n\n  if (!node) {\n    return null\n  }\n\n  const resolvedNodes = resolvedNodesCache.get(typeName)\n\n  if (resolvedNodes) {\n    node.__gatsby_resolved = resolvedNodes.get(id)\n  }\n\n  return node\n}\n\nexport const addResolvedNodes = (\n  typeName: string,\n  resolvedNodes: IGatsbyNode[] = []\n): IGatsbyNode[] => {\n  const { nodesByType, resolvedNodesCache } = store.getState()\n  const nodes = nodesByType.get(typeName)\n\n  if (!nodes) {\n    return []\n  }\n\n  const resolvedNodesFromCache = resolvedNodesCache.get(typeName)\n\n  nodes.forEach(node => {\n    if (resolvedNodesFromCache) {\n      node.__gatsby_resolved = resolvedNodesFromCache.get(node.id)\n    }\n    resolvedNodes.push(node)\n  })\n\n  return resolvedNodes\n}\n\nexport function postIndexingMetaSetup(\n  filterCache: IFilterCache,\n  op: FilterOp\n): void {\n  if (op === `$ne` || op === `$nin`) {\n    postIndexingMetaSetupNeNin(filterCache)\n  } else if ([`$lt`, `$lte`, `$gt`, `$gte`].includes(op)) {\n    postIndexingMetaSetupLtLteGtGte(filterCache, op)\n  }\n}\n\nfunction postIndexingMetaSetupNeNin(filterCache: IFilterCache): void {\n  // Note: edge cases regarding `null` and `undefined`. Here `undefined` signals\n  // that the property did not exist as sift does not support actual `undefined`\n  // values.\n  // For $ne, `null` only returns nodes that actually have the property\n  // and in that case the property cannot be `null` either. For any other value,\n  // $ne will return all nodes where the value is not actually the needle,\n  // including nodes where the value is null.\n  // A $nin does the same as an $ne except it filters multiple values instead\n  // of just one.\n\n  // For `$ne` we will take the list of all targeted nodes and eliminate the\n  // bucket of nodes with a particular value, if it exists at all. So for that\n  // reason we construct a flat list here to create new Set instances from.\n\n  const arr: Array<IGatsbyNode> = []\n  filterCache.meta.nodesUnordered = arr\n  filterCache.byValue.forEach(v => {\n    v.forEach(node => {\n      arr.push(node)\n    })\n  })\n}\n\nfunction postIndexingMetaSetupLtLteGtGte(\n  filterCache: IFilterCache,\n  op: FilterOp\n): void {\n  // Create an ordered array of individual nodes, ordered (grouped) by the\n  // value to which the filter resolves. Nodes are not ordered per value.\n  // This way non-eq ops can simply slice the array to get a range.\n\n  const entriesNullable: Array<[FilterValueNullable, Set<IGatsbyNode>]> = [\n    ...filterCache.byValue.entries(),\n  ]\n\n  // These range checks never return `null` or `undefined` so filter those out\n  // By filtering them out early, the sort should be faster. Could be ...\n  const entries: Array<[\n    FilterValue,\n    Set<IGatsbyNode>\n  ]> = entriesNullable.filter(([v]) => v != null) as Array<\n    [FilterValue, Set<IGatsbyNode>]\n  >\n\n  // Sort all sets by its value, asc. Ignore/allow potential type casting.\n  // Note: while `<` is the inverse of `>=`, the ordering might coerce values.\n  // This coercion makes the op no longer idempotent (normally the result of\n  // `a < b` is the opposite of `b >= a` for any a or b of the same type). The\n  // exception is a number that is `NaN`, which we're ignoring here as it's most\n  // likely a bug in the user code. However, when coercing the ops may end up\n  // comparing against `NaN`, too. For example: `(\"abc\" <= 12) !== (12 > \"abc\")`\n  // which ends up doing `NaN <= 12` and `NaN > \"abc\"`, which will both yield\n  // false.\n  // So instead we potentially track two ordered lists; ascending and descending\n  // and the only difference when comparing the inverse of one to the other\n  // should be how these `NaN` cases end up getting ordered.\n  // It's fine for `lt` and `lte` to use the same ordered set. Same for gt/gte.\n  if (op === `$lt` || op === `$lte`) {\n    // Order ascending; first value is lowest\n    entries.sort(([a], [b]) => (a < b ? -1 : a > b ? 1 : 0))\n  } else if (op === `$gt` || op === `$gte`) {\n    // Order descending; first value is highest\n    entries.sort(([a], [b]) => (a > b ? -1 : a < b ? 1 : 0))\n  }\n\n  const orderedNodes: Array<IGatsbyNode> = []\n  const orderedValues: Array<FilterValue> = []\n  const offsets: Map<FilterValue, [number, number]> = new Map()\n  entries.forEach(([v, bucket]: [FilterValue, Set<IGatsbyNode>]) => {\n    // Record the range containing all nodes with as filter value v\n    // The last value of the range should be the offset of the next value\n    // (So you should be able to do `nodes.slice(start, stop)` to get them)\n    offsets.set(v, [orderedNodes.length, orderedNodes.length + bucket.size])\n    // We could do `arr.push(...bucket)` here but that's not safe with very\n    // large sets, so we use a regular loop\n    bucket.forEach(node => orderedNodes.push(node))\n    orderedValues.push(v)\n  })\n\n  if (op === `$lt` || op === `$lte`) {\n    filterCache.meta.valuesAsc = orderedValues\n    filterCache.meta.nodesByValueAsc = orderedNodes\n    // The nodesByValueAsc is ordered by value, but multiple nodes per value are\n    // not ordered. To make lt as fast as lte, we must know the start and stop\n    // index for each value. Similarly useful for for `ne`.\n    filterCache.meta.valueRangesAsc = offsets\n  } else if (op === `$gt` || op === `$gte`) {\n    filterCache.meta.valuesDesc = orderedValues\n    filterCache.meta.nodesByValueDesc = orderedNodes\n    // The nodesByValueDesc is ordered by value, but multiple nodes per value are\n    // not ordered. To make gt as fast as gte, we must know the start and stop\n    // index for each value. Similarly useful for for `ne`.\n    filterCache.meta.valueRangesDesc = offsets\n  }\n}\n\n/**\n * Given a single non-elemMatch filter path, a set of node types, and a\n * cache, create a cache that for each resulting value of the filter contains\n * all the Nodes in a Set.\n * This cache is used for applying the filter and is a massive improvement over\n * looping over all the nodes, when the number of pages (/nodes) scales up.\n */\nexport const ensureIndexByQuery = (\n  op: FilterOp,\n  filterCacheKey: FilterCacheKey,\n  filterPath: string[],\n  nodeTypeNames: string[],\n  filtersCache: FiltersCache\n): void => {\n  const state = store.getState()\n  const resolvedNodesCache = state.resolvedNodesCache\n\n  const filterCache: IFilterCache = {\n    op,\n    byValue: new Map<FilterValueNullable, Set<IGatsbyNode>>(),\n    meta: {},\n  } as IFilterCache\n  filtersCache.set(filterCacheKey, filterCache)\n\n  // We cache the subsets of nodes by type, but only one type. So if searching\n  // through one node type we can prevent a search through all nodes, otherwise\n  // it's probably faster to loop through all nodes. Perhaps. Maybe.\n\n  if (nodeTypeNames.length === 1) {\n    getNodesByType(nodeTypeNames[0]).forEach(node => {\n      addNodeToFilterCache(node, filterPath, filterCache, resolvedNodesCache)\n    })\n  } else {\n    // Here we must first filter for the node type\n    // This loop is expensive at scale (!)\n    state.nodes.forEach(node => {\n      if (!nodeTypeNames.includes(node.internal.type)) {\n        return\n      }\n\n      addNodeToFilterCache(node, filterPath, filterCache, resolvedNodesCache)\n    })\n  }\n\n  postIndexingMetaSetup(filterCache, op)\n}\n\nexport function ensureEmptyFilterCache(\n  filterCacheKey,\n  nodeTypeNames: string[],\n  filtersCache: FiltersCache\n): void {\n  // This is called for queries without any filters\n  // We want to cache the result since it's basically a set of nodes by type(s)\n  // There are sites that have multiple queries which are empty\n\n  const state = store.getState()\n  const resolvedNodesCache = state.resolvedNodesCache\n  const nodesUnordered: Array<IGatsbyNode> = []\n\n  filtersCache.set(filterCacheKey, {\n    op: `$eq`, // Ignore.\n    byValue: new Map<FilterValueNullable, Set<IGatsbyNode>>(),\n    meta: {\n      nodesUnordered, // This is what we want\n    },\n  })\n\n  if (nodeTypeNames.length === 1) {\n    getNodesByType(nodeTypeNames[0]).forEach(node => {\n      if (!node.__gatsby_resolved) {\n        const typeName = node.internal.type\n        const resolvedNodes = resolvedNodesCache.get(typeName)\n        const resolved = resolvedNodes?.get(node.id)\n        if (resolved !== undefined) {\n          node.__gatsby_resolved = resolved\n        }\n      }\n      nodesUnordered.push(node)\n    })\n  } else {\n    // Here we must first filter for the node type\n    // This loop is expensive at scale (!)\n    state.nodes.forEach(node => {\n      if (nodeTypeNames.includes(node.internal.type)) {\n        if (!node.__gatsby_resolved) {\n          const typeName = node.internal.type\n          const resolvedNodes = resolvedNodesCache.get(typeName)\n          const resolved = resolvedNodes?.get(node.id)\n          if (resolved !== undefined) {\n            node.__gatsby_resolved = resolved\n          }\n        }\n        nodesUnordered.push(node)\n      }\n    })\n  }\n}\n\nfunction addNodeToFilterCache(\n  node: IGatsbyNode,\n  chain: Array<string>,\n  filterCache: IFilterCache,\n  resolvedNodesCache,\n  valueOffset: any = node\n): void {\n  // There can be a filter that targets `__gatsby_resolved` so fix that first\n  if (!node.__gatsby_resolved) {\n    const typeName = node.internal.type\n    const resolvedNodes = resolvedNodesCache.get(typeName)\n    node.__gatsby_resolved = resolvedNodes?.get(node.id)\n  }\n\n  // - for plain query, valueOffset === node\n  // - for elemMatch, valueOffset is sub-tree of the node to continue matching\n  let v = valueOffset as any\n  let i = 0\n  while (i < chain.length && v) {\n    const nextProp = chain[i++]\n    v = v[nextProp]\n  }\n\n  if (\n    (typeof v !== `string` &&\n      typeof v !== `number` &&\n      typeof v !== `boolean` &&\n      v !== null) ||\n    i !== chain.length\n  ) {\n    if (i === chain.length && Array.isArray(v)) {\n      // The op resolved to an array\n      // Add an entry for each element of the array. This would work for ops\n      // like eq and ne, but not sure about range ops like lt,lte,gt,gte.\n\n      v.forEach(v => markNodeForValue(filterCache, node, v))\n\n      return\n    }\n\n    // This means that either\n    // - The filter resolved to `undefined`, or\n    // - The filter resolved to something other than a primitive\n    // Set the value to `undefined` to mark \"path does not (fully) exist\"\n    v = undefined\n  }\n\n  markNodeForValue(filterCache, node, v)\n}\n\nfunction markNodeForValue(filterCache, node, value): void {\n  let set = filterCache.byValue.get(value)\n  if (!set) {\n    set = new Set()\n    filterCache.byValue.set(value, set)\n  }\n  set.add(node)\n}\n\nexport const ensureIndexByElemMatch = (\n  op: FilterOp,\n  filterCacheKey: FilterCacheKey,\n  filter: IDbQueryElemMatch,\n  nodeTypeNames: Array<string>,\n  filtersCache: FiltersCache\n): void => {\n  // Given an elemMatch filter, generate the cache that contains all nodes that\n  // matches a given value for that sub-query\n\n  const state = store.getState()\n  const { resolvedNodesCache } = state\n\n  const filterCache: IFilterCache = {\n    op,\n    byValue: new Map<FilterValueNullable, Set<IGatsbyNode>>(),\n    meta: {},\n  } as IFilterCache\n  filtersCache.set(filterCacheKey, filterCache)\n\n  if (nodeTypeNames.length === 1) {\n    getNodesByType(nodeTypeNames[0]).forEach(node => {\n      addNodeToBucketWithElemMatch(\n        node,\n        node,\n        filter,\n        filterCache,\n        resolvedNodesCache\n      )\n    })\n  } else {\n    // Expensive at scale\n    state.nodes.forEach(node => {\n      if (!nodeTypeNames.includes(node.internal.type)) {\n        return\n      }\n\n      addNodeToBucketWithElemMatch(\n        node,\n        node,\n        filter,\n        filterCache,\n        resolvedNodesCache\n      )\n    })\n  }\n\n  postIndexingMetaSetup(filterCache, op)\n}\n\nfunction addNodeToBucketWithElemMatch(\n  node: IGatsbyNode,\n  valueAtCurrentStep: any, // Arbitrary step on the path inside the node\n  filter: IDbQueryElemMatch,\n  filterCache: IFilterCache,\n  resolvedNodesCache\n): void {\n  // There can be a filter that targets `__gatsby_resolved` so fix that first\n  if (!node.__gatsby_resolved) {\n    const typeName = node.internal.type\n    const resolvedNodes = resolvedNodesCache.get(typeName)\n    node.__gatsby_resolved = resolvedNodes?.get(node.id)\n  }\n\n  const { path, nestedQuery } = filter\n\n  // Find the value to apply elemMatch to\n  let i = 0\n  while (i < path.length && valueAtCurrentStep) {\n    const nextProp = path[i++]\n    valueAtCurrentStep = valueAtCurrentStep[nextProp]\n  }\n\n  if (path.length !== i) {\n    // Found undefined before the end of the path, so let Sift take over\n    return\n  }\n\n  // `v` should now be an elemMatch target, probably an array (but maybe not)\n  if (!Array.isArray(valueAtCurrentStep)) {\n    // It's possible to `elemMatch` on a non-array so let's support that too\n    valueAtCurrentStep = [valueAtCurrentStep]\n  }\n\n  // Note: We need to check all elements because the node may need to be added\n  // to multiple buckets (`{a:[{b:3},{b:4}]}`, for `a.elemMatch.b/eq` that\n  // node ends up in buckets for value 3 and 4. This may lead to duplicate\n  // work when elements resolve to the same value, but that can't be helped.\n  valueAtCurrentStep.forEach(elem => {\n    if (nestedQuery.type === `elemMatch`) {\n      addNodeToBucketWithElemMatch(\n        node,\n        elem,\n        nestedQuery,\n        filterCache,\n        resolvedNodesCache\n      )\n    } else {\n      // Now take same route as non-elemMatch filters would take\n      addNodeToFilterCache(\n        node,\n        nestedQuery.path,\n        filterCache,\n        resolvedNodesCache,\n        elem\n      )\n    }\n  })\n}\n\nconst binarySearchAsc = (\n  values: Array<FilterValue>, // Assume ordered asc\n  needle: FilterValue\n): [number, number] | undefined => {\n  let min = 0\n  let max = values.length - 1\n  let pivot = Math.floor(values.length / 2)\n  while (min <= max) {\n    const value = values[pivot]\n    if (needle < value) {\n      // Move pivot to middle of nodes left of current pivot\n      // assert pivot < max\n      max = pivot\n    } else if (needle > value) {\n      // Move pivot to middle of nodes right of current pivot\n      // assert pivot > min\n      min = pivot\n    } else {\n      // This means needle === value\n      // TODO: except for NaN ... and potentially certain type casting cases\n      return [pivot, pivot]\n    }\n\n    if (max - min <= 1) {\n      // End of search. Needle not found (as expected). Use pivot as index.\n      // If the needle was not found, max-min==1 and max is returned.\n      return [min, max]\n    }\n\n    pivot = min + Math.floor((max - min) / 2)\n  }\n\n  // Shouldn't be reachable, but just in case, fall back to Sift if so.\n  return undefined\n}\nconst binarySearchDesc = (\n  values: Array<FilterValue>, // Assume ordered desc\n  needle: FilterValue\n): [number, number] | undefined => {\n  let min = 0\n  let max = values.length - 1\n  let pivot = Math.floor(values.length / 2)\n  while (min <= max) {\n    const value = values[pivot]\n    if (needle < value) {\n      // Move pivot to middle of nodes right of current pivot\n      // assert pivot < min\n      min = pivot\n    } else if (needle > value) {\n      // Move pivot to middle of nodes left of current pivot\n      // assert pivot > max\n      max = pivot\n    } else {\n      // This means needle === value\n      // TODO: except for NaN ... and potentially certain type casting cases\n      return [pivot, pivot]\n    }\n\n    if (max - min <= 1) {\n      // End of search. Needle not found (as expected). Use pivot as index.\n      // If the needle was not found, max-min==1 and max is returned.\n      return [min, max]\n    }\n\n    pivot = min + Math.floor((max - min) / 2)\n  }\n\n  // Shouldn't be reachable, but just in case, fall back to Sift if so.\n  return undefined\n}\n\n/**\n * Given the cache key for a filter and a target value return the set of nodes\n * that resolve to this value.\n * This returns `undefined` if there is no such node\n *\n * Basically if the filter was {a: {b: {slug: {eq: \"foo/bar\"}}}} then it will\n * return all the nodes that have `node.slug === \"foo/bar\"`. That usually (but\n * not always) at most one node for slug, but this filter can apply to anything.\n */\nexport const getNodesFromCacheByValue = (\n  filterCacheKey: FilterCacheKey,\n  filterValue: FilterValueNullable,\n  filtersCache: FiltersCache\n): Set<IGatsbyNode> | undefined => {\n  const filterCache = filtersCache?.get(filterCacheKey)\n  if (!filterCache) {\n    return undefined\n  }\n\n  const op = filterCache.op\n\n  if (op === `$eq`) {\n    if (filterValue == null) {\n      // Edge case; fetch all nodes for `null` and `undefined` because `$eq`\n      // also returns nodes without the path when searching for `null`. Not\n      // ops do so, so we map non-existing paths to `undefined`.\n      return new Set([\n        ...(filterCache.byValue.get(null) ?? []),\n        ...(filterCache.byValue.get(undefined) ?? []),\n      ])\n    }\n    return filterCache.byValue.get(filterValue)\n  }\n\n  if (op === `$in`) {\n    if (!Array.isArray(filterValue)) {\n      // Sift assumes the value has an `indexOf` property. By this fluke,\n      // string args would work, but I don't think that's intentional/expected.\n      throw new Error(\"The argument to the `in` comparator should be an array\")\n    }\n    const filterValueArr: Array<FilterValueNullable> = filterValue\n\n    const set = new Set<IGatsbyNode>()\n    if (filterValueArr.includes(null)) {\n      // Like all other ops, `in: [null]` behaves weirdly, allowing all nodes\n      // that do not actually have a (complete) path (v=undefined)\n      const nodes = filterCache.byValue.get(undefined)\n      if (nodes) {\n        nodes.forEach(v => set.add(v))\n      }\n    }\n\n    // For every value in the needle array, find the bucket of nodes for\n    // that value, add this bucket of nodes to one set, return the set.\n    filterValueArr\n      .slice(0) // Sort is inline so slice the original array\n      .sort((a, b) => {\n        if (a == null || b == null) return 0\n        return a < b ? -1 : a > b ? 1 : 0\n      }) // Just sort to preserve legacy order as much as possible.\n      .forEach((v: FilterValueNullable) =>\n        filterCache.byValue.get(v)?.forEach(v => set.add(v))\n      )\n\n    return set\n  }\n\n  if (op === `$nin`) {\n    // This is essentially the same as the $ne operator, just with multiple\n    // values to exclude.\n\n    if (!Array.isArray(filterValue)) {\n      throw new Error(`The $nin operator expects an array as value`)\n    }\n\n    const values: Set<FilterValueNullable> = new Set(filterValue)\n    const set = new Set(filterCache.meta.nodesUnordered)\n\n    // Do the action for \"$ne\" for each element in the set of values\n    values.forEach(filterValue => {\n      if (filterValue === null) {\n        // Edge case: $nin with `null` returns only the nodes that contain the\n        // full path and that don't resolve to null, so drop `undefined` as well\n        let cache = filterCache.byValue.get(undefined)\n        if (cache) cache.forEach(node => set.delete(node))\n        cache = filterCache.byValue.get(null)\n        if (cache) cache.forEach(node => set.delete(node))\n      } else {\n        // Not excluding null so it should include undefined leafs or leafs\n        // where only the partial path exists for whatever reason.\n        const cache = filterCache.byValue.get(filterValue)\n        if (cache) cache.forEach(node => set.delete(node))\n      }\n    })\n\n    return set\n  }\n\n  if (op === `$ne`) {\n    const set = new Set(filterCache.meta.nodesUnordered)\n\n    if (filterValue === null) {\n      // Edge case: $ne with `null` returns only the nodes that contain the full\n      // path and that don't resolve to null, so drop `undefined` as well.\n      let cache = filterCache.byValue.get(undefined)\n      if (cache) cache.forEach(node => set.delete(node))\n      cache = filterCache.byValue.get(null)\n      if (cache) cache.forEach(node => set.delete(node))\n    } else {\n      // Not excluding null so it should include undefined leafs or leafs where\n      // only the partial path exists for whatever reason.\n      const cache = filterCache.byValue.get(filterValue)\n      if (cache) cache.forEach(node => set.delete(node))\n    }\n\n    return set\n  }\n\n  if (op === `$regex`) {\n    // Note: $glob is converted to $regex so $glob filters go through here, too\n    // Aside from the input pattern format, further behavior is exactly the same.\n\n    // The input to the filter must be a string (including leading/trailing slash and regex flags)\n    // By the time the filter reaches this point, the filterValue has to be a regex.\n\n    if (!(filterValue instanceof RegExp)) {\n      throw new Error(\n        `The value for the $regex comparator must be an instance of RegExp`\n      )\n    }\n    const regex = filterValue\n\n    const result = new Set<IGatsbyNode>()\n    filterCache.byValue.forEach((nodes, value) => {\n      // TODO: does the value have to be a string for $regex? Can we auto-ignore any non-strings? Or does it coerce.\n      // Note: partial paths should also be included for regex (matching Sift behavior)\n      if (value !== undefined && regex.test(String(value))) {\n        nodes.forEach(node => result.add(node))\n      }\n    })\n\n    // TODO: we _can_ cache this set as well. Might make sense if it turns out that $regex is mostly used with literals\n    return result\n  }\n\n  if (filterValue == null) {\n    if (op === `$lt` || op === `$gt`) {\n      // Nothing is lt/gt null\n      return undefined\n    }\n\n    // This is an edge case and this value should be directly indexed\n    // For `lte`/`gte` this should only return nodes for `null`, not a \"range\"\n    return filterCache.byValue.get(filterValue)\n  }\n\n  if (Array.isArray(filterValue)) {\n    throw new Error(\n      \"Array is an invalid filter value for the `\" + op + \"` comparator\"\n    )\n  }\n\n  if (filterValue instanceof RegExp) {\n    // This is most likely an internal error, although it is possible for\n    // users to talk to this API more directly.\n    throw new Error(\n      `A RegExp instance is only valid for $regex and $glob comparators`\n    )\n  }\n\n  if (op === `$lt`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole set, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesAsc\n    const nodes = filterCache.meta.nodesByValueAsc\n\n    const range = ranges!.get(filterValue)\n    if (range) {\n      return new Set(nodes!.slice(0, range[0]))\n    }\n\n    // Query may ask for a value that doesn't appear in the set, like if the\n    // set is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for lte, the valueAsc array must be set at this point\n    const values = filterCache.meta.valuesAsc as Array<FilterValue>\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchAsc(values, filterValue)\n    if (!point) {\n      return undefined\n    }\n    const [pivotMin, pivotMax] = point\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do lte checks for both values.\n    let pivotValue = values[pivotMax]\n    if (pivotValue > filterValue) {\n      pivotValue = values[pivotMin]\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number]\n\n    // Note: technically, `5 <= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue < filterValue ? inclPivot : exclPivot\n    return new Set(nodes!.slice(0, until))\n  }\n\n  if (op === `$lte`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole set, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesAsc\n    const nodes = filterCache.meta.nodesByValueAsc\n\n    const range = ranges!.get(filterValue)\n    if (range) {\n      return new Set(nodes!.slice(0, range[1]))\n    }\n\n    // Query may ask for a value that doesn't appear in the set, like if the\n    // set is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for lte, the valueAsc array must be set at this point\n    const values = filterCache.meta.valuesAsc as Array<FilterValue>\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchAsc(values, filterValue)\n    if (!point) {\n      return undefined\n    }\n    const [pivotMin, pivotMax] = point\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do lte checks for both values.\n    let pivotValue = values[pivotMax]\n    if (pivotValue > filterValue) {\n      pivotValue = values[pivotMin]\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number]\n\n    // Note: technically, `5 <= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue <= filterValue ? inclPivot : exclPivot\n    return new Set(nodes!.slice(0, until))\n  }\n\n  if (op === `$gt`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole set, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesDesc\n    const nodes = filterCache.meta.nodesByValueDesc\n\n    const range = ranges!.get(filterValue)\n    if (range) {\n      return new Set(nodes!.slice(0, range[0]))\n    }\n\n    // Query may ask for a value that doesn't appear in the set, like if the\n    // set is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for gte, the valueDesc array must be set at this point\n    const values = filterCache.meta.valuesDesc as Array<FilterValue>\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchDesc(values, filterValue)\n    if (!point) {\n      return undefined\n    }\n    const [pivotMin, pivotMax] = point\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do gte checks for both values.\n    let pivotValue = values[pivotMax]\n    if (pivotValue < filterValue) {\n      pivotValue = values[pivotMin]\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number]\n\n    // Note: technically, `5 >= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue > filterValue ? inclPivot : exclPivot\n    return new Set(nodes!.slice(0, until))\n  }\n\n  if (op === `$gte`) {\n    // First try a direct approach. If a value is queried that also exists then\n    // we can prevent a binary search through the whole set, O(1) vs O(log n)\n\n    const ranges = filterCache.meta.valueRangesDesc\n    const nodes = filterCache.meta.nodesByValueDesc\n\n    const range = ranges!.get(filterValue)\n    if (range) {\n      return new Set(nodes!.slice(0, range[1]))\n    }\n\n    // Query may ask for a value that doesn't appear in the set, like if the\n    // set is [1, 2, 5, 6] and the query is <= 3. In that case we have to\n    // apply a search (we'll do binary) to determine the offset to slice from.\n\n    // Note: for gte, the valueDesc array must be set at this point\n    const values = filterCache.meta.valuesDesc as Array<FilterValue>\n    // It shouldn't find the targetValue (but it might) and return the index of\n    // the two value between which targetValue sits, or first/last element.\n    const point = binarySearchDesc(values, filterValue)\n    if (!point) {\n      return undefined\n    }\n    const [pivotMin, pivotMax] = point\n\n    // Each pivot index must have a value and a range\n    // The returned min/max index may include the lower/upper bound, so we still\n    // have to do gte checks for both values.\n    let pivotValue = values[pivotMax]\n    if (pivotValue < filterValue) {\n      pivotValue = values[pivotMin]\n    }\n\n    // Note: the pivot value _shouldnt_ match the filter value because that\n    // means the value was actually found, but those should have been indexed\n    // so should have yielded a result in the .get() above.\n\n    const [exclPivot, inclPivot] = ranges!.get(pivotValue) as [number, number]\n\n    // Note: technically, `5 >= \"5\" === true` but `5` would not be cached.\n    // So we have to consider weak comparison and may have to include the pivot\n    const until = pivotValue >= filterValue ? inclPivot : exclPivot\n    return new Set(nodes!.slice(0, until))\n  }\n\n  // Unreachable because we checked all values of FilterOp (which op is)\n  return undefined\n}\n"],"file":"nodes.js"}